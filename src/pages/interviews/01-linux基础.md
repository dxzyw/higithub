<img src="/assets/image/linux.png" style="max-width: 70%; height: auto;">

<small>linux相关基础</small>

# linux相关 {#linux-basic}

## 什么是 Linux？ {#linux-intro}


百科：“Linux 是一系列基于 Linux 内核的开源类 Unix 操作系统的家族，Linux 内核是一个于 1991 年 9 月 17 日由 Linus Torvalds 首次发布的操作系统内核。Linux 通常以 Linux 发行版的形式打包。”


Red Hat：“Linux® 是一种开源操作系统（OS）。操作系统是直接管理系统的硬件和资源（如 CPU、内存和存储）的软件。操作系统位于应用程序和硬件之间，建立了所有软件和执行工作的物理资源之间的连接。”

## 解释以下每个命令的作用：

touch

ls

rm

cat

cp

mkdir

pwd

cd


touch - 更新文件的时间戳。更常用于创建文件

ls - 列出文件和目录

rm - 删除文件和目录

cat - 创建、查看和连接文件

cp - 复制文件和目录

mkdir - 创建目录

pwd - 打印当前工作目录（=用户当前所在的路径）

cd - 切换目录

## 以下每个命令的作用是什么？ {#linux-cd-commands}

cd /

cd ~

cd

cd ..

cd .

cd -


cd / -> 切换到根目录

cd ~ -> 切换到你的主目录

cd -> 切换到你的主目录

cd .. -> 切换到你当前目录的上一级，即父目录

cd . -> 切换到你当前所在的目录

cd - -> 切换到上次访问的路径

前面问题中的一些命令可以用 -r/-R 标志运行。它有什么作用？举一个你会用到它的例子


-r（或 -R 在某些命令中）标志允许用户递归地运行某个命令。例如，列出以下树中的所有文件是可能的，当用递归方式（ls -R）：


/dir1/ dir2/ file1 file2 dir3/ file3


要列出所有文件，可以运行 ls -R /dir1


## 解释 `ls -l` 命令的输出中的每个字段


它以长格式显示文件的详细列表。从左边开始：

文件权限，链接数，所有者名，所有者组，文件大小，最后修改的时间戳和目录/文件名

## 什么是隐藏文件/目录？如何列出它们？


这些是在执行标准 ls 直接列表后直接不显示的文件。这些文件的例子是 .bashrc，它们用于执行一些脚本。有些还存储了关于你主机上的服务的配置，比如 .KUBECONFIG。用于列出它们的命令是，ls -a


## > 和 < 在程序的输入和输出方面有什么作用？


它们使用 stdin 和 stdout 为给定文件接收输入（<）和输出（>）。

myProgram < input.txt > executionOutput.txt


## 解释以下每个命令的作用，并给出如何使用它的例子：

sed

grep

cut

awk


sed: 一个流编辑器。可以用于各种目的，比如在文件中替换一个单词：sed -i s/salad/burger/g

grep: 一个搜索工具。用于在文件中搜索、计数或匹配文本：

在文件中搜索包含一个单词的任何行：grep 'word' file.md

或显示一个字符串在文件中出现的总次数：grep -c 'This is a string' file.md

cut: 一个用于剪切文件中每行的选定部分的工具：

语法：cut OPTION [FILE]

从文件中的一个单词中剪切前两个字节：cut -b 1-2 file.md，输出：wo

awk: 一个主要用于文本处理和数据提取的编程语言。它可以用于操作和修改文件中的文本：

语法：awk [OPTIONS] [FILTER] [FILE] 从 CSV 文件中提取一个特定的字段：awk -F ',' '{print $1}' file.csv，输出：文件中每行的第一个字段

## 如何重命名文件或目录的名称？

mv

## 指定你会使用哪个命令（以及如何使用）来完成以下每个场景

删除一个带有文件的目录

显示文件的内容

为所有人提供对 /tmp/x 文件的访问权限

切换工作目录到用户主目录

在 /tmp/y 文件中替换单词“good”为“great”的每次出现


rm -rf dir

cat 或 less

chmod 777 /tmp/x

cd ~

sed -i s/good/great/g /tmp/y

## 你怎么能检查一个特定命令的路径是什么？


whereis

which

## 这两个命令有什么区别？它们会产生相同的输出吗？

echo hello world

echo "hello world"


echo 命令在第一次执行时接收两个单独的参数，在第二次执行时接收一个参数，即字符串 "hello world"。输出将是相同的。


## 解释什么是管道。你如何执行管道操作？


在 Linux 中使用管道，可以将一个命令的输出发送到另一个命令的输入。例如：cat /etc/services | wc -l


修复以下命令：

sed "s/1/2/g' /tmp/myFile

find . -iname *.yaml -exec sed -i "s/1/2/g" {} ;


sed 's/1/2/g' /tmp/myFile  # sed "s/1/2/g" 也可以

find . -iname "*.yaml" -exec sed -i "s/1/2/g" {} \;


## 如何检查你过去执行过哪些命令？


history 命令或 .bash_history 文件


也可以使用上箭头键来访问或显示你输入的最近的命令

运行 df 命令时，你得到“command not found”。可能是什么问题，如何解决？


最有可能的是默认/生成的 $PATH 被某种方式修改或覆盖了，因此不包含 /bin/，而 df 通常会在那里。这个问题也可能发生在 bash_profile 或你的解释器的任何配置文件被错误地修改，导致不正常的行为。你可以通过修复你的 $PATH 变量来解决这个问题：


要修复它有几种方法：


手动添加你需要的东西到你的 $PATH PATH="$PATH":/user/bin:/..etc

你有你的奇怪的环境变量备份。

你可以查找你的发行版默认的 $PATH 变量，复制粘贴使用方法 #1

注意：有很多导致这样的错误的方法：如果 bash_profile 或你的解释器的任何配置文件被错误地修改；导致不正常的行为，权限问题，编译不好的软件（如果你自己编译的话）...没有一个答案会在 100% 的时间内是正确的。


## 你如何定期安排任务？


你可以使用 cron 和 at 命令。使用 cron，任务按照以下格式安排：


*/30 * * * * bash myscript.sh 每 30 分钟执行一次脚本。


任务被存储在一个 cron 文件中，你可以使用 crontab -e 来写入它


另外，如果你使用的是带有 systemd 的发行版，建议使用 systemd 定时器。

## I/O 重定向

## 解释 Linux I/O 重定向


在 Linux 中，I/O 重定向是一种改变命令或程序的默认输入/输出行为的方法。它允许你将输入和输出从/到不同的源/目的地重定向，比如文件、设备和其他命令。

## 这里有一些常见的 I/O 重定向的例子：


重定向标准输出（stdout）：ls > filelist.txt

重定向标准错误（stderr）：ls /some/nonexistent/directory 2> error.txt

追加到文件：echo "hello" >> myfile.txt

重定向输入（stdin）：sort < unsorted.txt

使用管道：Pipes ("|")：ls | grep ".txt$"

演示 Linux 输出重定向


ls > ls_output.txt


演示 Linux 标准错误输出重定向


yippiekaiyay 2> ls_output.txt


演示 Linux 标准错误到标准输出重定向


yippiekaiyay &> file


## 运行以下命令的结果是什么？yippiekaiyay 1>&2 die_hard


一个类似于：yippikaiyay: command not found... 的输出

die_hard 文件不会被创建



## 文件系统层次标准

在 Linux FHS（文件系统层次标准）中，/ 是什么？


文件系统的根。树的开始。


## 以下路径中各存储了什么？

/bin, /sbin, /usr/bin and /usr/sbin

/etc

/home

/var

/tmp


二进制文件

配置文件

不同用户的主目录

倾向于改变和被修改的文件，比如日志

临时文件

/tmp 目录与其他目录相比有什么特别之处？


/tmp 文件夹通常在重启时自动清理。


/proc 中可以找到什么样的信息？


它包含了有关当前运行的进程的有用信息，它被视为内核的控制和信息中心。


/proc 与其他文件系统有什么不同？


/proc 是一个虚拟文件系统，它不占用磁盘空间，而是直接反映了内核和进程的状态。


## 对还是错？只有 root 用户可以在 /proc 中创建文件


错。没有人可以直接在 /proc 中创建文件（某些操作可以导致内核在 /proc 中创建文件）。


## /proc/cmdline 中可以找到什么？


传递给引导加载程序以运行内核的命令


## 在哪个路径下可以找到系统设备（例如块存储）？


/dev


## 权限

## 如何改变文件的权限？


使用 chmod 命令。


## 以下权限分别代表什么意思？

777

644

750


777 - 你给所有者、组和其他人：执行（1）、写（2）和读（4）；4+2+1 = 7。

644 - 所有者有读（4）、写（2），4+2 = 6；组和其他人有读（4）。

750 - 所有者有 x+r+w，组有读（4）和执行（1）；4+1 = 5。其他人没有权限。


## 这个命令做了什么？chmod +x some_file


它给所有集合，即用户、组和其他人添加执行权限

## 解释什么是 setgid 和 setuid


setuid 是一种 linux 文件权限，它允许用户以文件所有者的权限运行文件或程序。这是通过提升当前用户权限实现的。

setgid 是一种当执行时将以拥有文件的组运行的进程。

## 粘滞位的作用是什么？


它是一种只允许所有者或 root 用户删除或修改文件的位。

## 以下命令分别做了什么？

chmod

chown

chgrp


chmod - 改变文件系统对象的访问权限

chown - 改变文件系统文件和目录的所有者

chgrp - 改变与文件系统对象相关联的组

## 什么是 sudo？你如何设置它？


sudo 是一种允许用户以另一个用户（通常是 root 用户）的身份执行命令的程序。你可以通过编辑 /etc/sudoers 文件或使用 visudo 命令来设置它，为用户或组分配不同的权限和角色。


## 对还是错？为了在系统上安装软件包，必须是 root 用户或使用 sudo 命令


对


## 解释什么是 ACL。你会推荐在什么情况下使用它们？


ACL 是访问控制列表的缩写，它是一种为文件或目录设置更细粒度的权限的方法。你可以使用 setfacl 和 getfacl 命令来设置和查看 ACL。你会推荐在以下情况下使用它们：


当你需要给不同的用户或组分配不同的访问权限时

当你需要给文件或目录设置特殊的权限，比如 setuid、setgid 或粘滞位时

当你需要覆盖文件或目录的默认权限时

## 你试图创建一个文件，但失败了。至少说出三个可能的原因


没有更多的磁盘空间

没有更多的索引节点

没有权限

## 一个用户不小心执行了以下命令 chmod -x $(which chmod)。如何修复？


使用 sudo setfacl -m u::rx /usr/bin/chmod 会给所有用户设置 chmod 的执行权限。之后，chmod 二进制文件可以像往常一样使用。



## 场景

## 你想把一个文件复制到一个远程的 Linux 主机上。你会怎么做？


有多种方法可以在主机之间传输文件。个人意见：使用 rsync


## 如何生成一个随机字符串？


一种方法是运行以下命令：cat /proc/sys/kernel/random/uuid


## 如何生成一个 7 个字符的随机字符串？


mkpasswd -l 7



## Systemd

## 什么是 systemd？


Systemd 是一个守护进程（System 'd'，d 代表守护进程）。

守护进程是一种在后台运行，不受用户直接控制的程序，但用户可以随时与守护进程通信。


systemd 有许多特性，如用户进程的控制/跟踪、快照支持、抑制锁等。


如果我们将 unix/linux 系统分层可视化，systemd 将直接位于 linux 内核之后。

硬件 -> 内核 -> 守护进程、系统库、显示服务器。


## 如何启动或停止一个服务？


要启动一个服务：systemctl start <service name> 要停止一个服务：systemctl stop <service name>


## 如何检查一个服务的状态？


systemctl status <service name>


## 在一个使用 systemd 的系统上，你会如何显示日志？


journalctl

## 故障排除和调试

## 系统日志在哪里？


/var/log


## 如何在不每次打开文件的情况下跟踪文件的内容？


tail -f <file_name>


## 你用什么来故障排除和调试网络问题？


dstat -t 很适合识别网络和磁盘问题。netstat -tnlaup 可以用来查看哪些进程在哪些端口上运行。lsof -i -P 可以用来达到与 netstat 相同的目的。ngrep -d any metafilter 用于匹配数据包的有效载荷的正则表达式。tcpdump 用于捕获数据包 wireshark 与 tcpdump 同样的概念，但有 GUI（可选）。


## 你用什么来故障排除和调试磁盘和文件系统问题？


dstat -t 很适合识别网络和磁盘问题。opensnoop 可以用来查看系统上正在打开的文件（实时）。


## 你用什么来故障排除和调试进程问题？


strace 很适合理解你的程序做了什么。它打印出你的程序执行的每个系统调用。


## 你用什么来调试 CPU 相关的问题？


top 会显示每个进程消耗的 CPU 百分比 perf 是一个很好的选择，用于采样分析器，以及总体上弄清楚你的 CPU 周期被“浪费”在哪里 flamegraphs 很适合 CPU 消耗的可视化（[http://www.brendangregg.com/flamegraphs.html](http://www.brendangregg.com/flamegraphs.html)）


## 你接到一个人的电话，说“我的系统很慢”。你会怎么做？


用 top 检查有没有什么异常

运行 dstat -t 检查是否与磁盘或网络有关。

检查是否与网络有关，用 sar

用 iostat 检查 I/O 统计

解释 iostat 输出

## 场景

你有一个进程正在写入一个文件。你不知道具体是哪个进程，你只知道文件的路径。你想杀掉这个进程，因为它不再需要了。你会怎么做？


运行 lsof <FILE_PATH>

使用 lsof 命令的 pid（进程 ID）并运行 kill <PID>


## 内核

## 什么是内核，它有什么作用？


内核是操作系统的一部分，负责如下任务：


分配内存

调度进程

控制 CPU

## 如何找出你的系统使用的内核版本？


uname -a 命令


## 什么是 Linux 内核模块，如何加载一个新的模块？


Linux 内核模块是一种可以在运行时动态加载或卸载的内核代码，它可以扩展内核的功能，而不需要重新编译或重启内核。要加载一个新的模块，可以使用 modprobe 或 insmod 命令。


## 解释用户空间和内核空间的区别


操作系统在受保护的内存中执行内核，以防止任何人修改（并冒着崩溃的风险）。这就是所谓的“内核空间”。“用户空间”是用户执行他们的命令或应用程序的地方。创建这种分离是很重要的，因为我们不能依赖用户应用程序不去篡改内核，导致它崩溃。


应用程序可以通过发出所谓的“系统调用”来访问系统资源和间接地访问内核空间。


## 在内核生命周期的哪些阶段，你可以改变它的配置？


构建时（编译时）

启动时（启动时）

运行时（已经运行时）

## 你可以在哪里找到内核的配置？


通常它会位于 /boot/config-<kernel version>.<os release>.<arch>


## 你可以在哪里找到包含传递给引导加载程序以运行内核的命令的文件？


/proc/cmdline


## 如何列出内核的运行时参数？


sysctl -a


## 以普通用户和 root 用户运行 sysctl -a，会产生不同的结果吗？


是的，你可能会注意到，在大多数系统中，用 root 运行 systctl -a，你会得到更多的运行时参数，相比之下，用普通用户执行相同的命令。


## 你想在内核中启用 IPv4 转发，你会怎么做？


sudo sysctl net.ipv4.ip_forward=1


要使其持久化（例如在重启后应用）：在 /etc/sysctl.conf 中插入 net.ipv4.ip_forward = 1


另一种方法是运行 echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward


## sysctl 在你运行 sysctl 命令的时候，是如何应用内核运行时参数的变化的？


如果你 strace sysctl 命令，你可以看到它是通过改变 /proc/sys/... 下的文件来做的。


过去它是用 sysctl 系统调用来做的，但在某个时候被废弃了。


## 内核运行时参数的变化如何持久化？（例如在系统重启后也应用）


有一个叫 systemd-sysctl 的服务，它会取 /etc/sysctl.conf 的内容并应用它。这就是当它们被写入 /etc/sysctl.conf 时，即使在重启后，变化也会持久化的原因。


## 你在容器中对内核参数的改变，也会影响到运行容器的主机的内核参数吗？


不会。容器有自己的 /proc 文件系统，所以在容器内部对内核参数的任何改变，都不会影响到主机或该主机上运行的其他容器。



## SSH

## 什么是 SSH？如何检查一个 Linux 服务器是否运行 SSH？


维基百科定义：“SSH 或 Secure Shell 是一种加密的网络协议，用于在不安全的网络上安全地操作网络服务。”


Hostinger.com 定义：“SSH，或 Secure Shell，是一种远程管理协议，允许用户通过互联网控制和修改他们的远程服务器。”


一个 SSH 服务器会有 SSH 守护进程运行。取决于发行版，你应该能够检查服务是否运行（例如 systemctl status sshd）。


## 为什么 SSH 比 telnet 更好？


Telnet 也允许你连接到一个远程主机，但与 SSH 不同的是，SSH 中的通信是加密的，而 telnet 中的数据是明文发送的，所以它不被认为是安全的，因为网络上的任何人都可以看到发送的内容，包括密码。


## ~/.ssh/known_hosts 中存储了什么？


该文件存储了连接到 SSH 服务器的客户端的密钥指纹。这个指纹在客户端和服务器之间建立了未来 SSH 连接的信任。


## 你试图 ssh 到一个服务器，但你得到“Host key verification failed”。这是什么意思？


这意味着远程主机的密钥已经改变，和你的机器上存储的密钥（在 ~/.ssh/known_hosts）不匹配。


## SSH 和 SSL 有什么区别？


SSH 和 SSL 都是用于在不安全的网络上安全地传输数据的加密协议，但它们有一些不同之处：


SSH 是一种远程管理协议，允许用户通过互联网控制和修改他们的远程服务器。SSH 使用公钥加密技术，每个主机都有一对公钥和私钥，用于验证身份和加密数据。SSH 通常使用 22 端口。

SSL 是一种安全套接字层协议，用于在客户端和服务器之间建立安全的连接，通常用于 Web 浏览器和 Web 服务器之间的通信。SSL 使用证书颁发机构（CA）来验证服务器的身份，并使用对称加密和非对称加密来保护数据。SSL 通常使用 443 端口。


## ssh-keygen 用来做什么？


ssh-keygen 是一个用于生成 SSH 认证密钥对的工具，它包括一个私钥和一个公钥。它支持多种算法来生成认证密钥：


dsa

ecdsa

ecdsa-sk

ed25519

ed25519-sk

rsa (默认)

也可以指定密钥的位数。下面的命令生成一个 RSA 4096 位的 SSH 密钥对：


$ ssh-keygen -t rsa -b 4096

输出看起来像这样：


Generating public/private rsa key pair.

Enter file in which to save the key (/home/user/.ssh/id_rsa): 

Enter passphrase (empty for no passphrase): 

Enter same passphrase again: 

Your identification has been saved in /home/user/.ssh/id_rsa

Your public key has been saved in /home/user/.ssh/id_rsa.pub

The key fingerprint is:

SHA256:f5MOGnhzYfC0ZCHvbSXXiRiNVYETjxpHcXD5xSojx+M user@mac-book-pro

The key's randomart image is:

+---[RSA 4096]----+

|        . ..+***o|

|         o o++*o+|

|        . =+.++++|

|         B.oX+. .|

|        S *=o+   |

|       . o oE.   |

|      . + + +    |

|       . = + .   |

|        .   .    |

+----[SHA256]-----+

可以用以下命令检查 SSH 密钥有多少位：


$ ssh-keygen -l -f /home/user/.ssh/id_rsa

输出应该像这样：


4096 SHA256:f5MOGnhzYfC0ZCHvbSXXiRiNVYETjxpHcXD5xSojx+M user@mac-book-pro (RSA)

它显示密钥是 RSA 4096 位。


-l 和 -f 参数的用法解释：


-l          显示密钥文件的指纹。

-f filename 密钥文件的文件名。


## 什么是 SSH 端口转发？


SSH 端口转发是一种利用 SSH 协议的特性，将本地或远程的端口通过安全的隧道映射到另一个端口的技术，可以用于实现跨防火墙的访问，或者保护不安全的协议。SSH 端口转发有三种类型：


**本地端口转发**：将本地机器的一个端口映射到远程机器的一个端口，使本地机器可以通过 SSH 隧道访问远程机器上的服务。例如，ssh -L 8080:localhost:80 user@remote.com 将本地机器的 8080 端口映射到远程机器的 80 端口，使本地机器可以通过 [http://localhost:8080](http://localhost:8080) 访问远程机器上的 Web 服务。

**远程端口转发**：将远程机器的一个端口映射到本地机器的一个端口，使远程机器可以通过 SSH 隧道访问本地机器上的服务。例如，ssh -R 8080:localhost:80 user@remote.com 将远程机器的 8080 端口映射到本地机器的 80 端口，使远程机器可以通过 [http://localhost:8080](http://localhost:8080) 访问本地机器上的 Web 服务。

**动态端口转发**：将本地机器的一个端口作为一个 SOCKS 代理服务器，使本地机器可以通过 SSH 隧道访问任何远程机器上的服务。例如，ssh -D 8080 user@remote.com 将本地机器的 8080 端口作为一个 SOCKS 代理服务器，使本地机器可以通过配置浏览器或其他应用程序使用 SOCKS 代理为 [http://localhost:8080](http://localhost:8080) 访问任何远程机器上的服务。

## 以下每个符号匹配什么

?

*


? 匹配任意单个字符

* 匹配零个或多个字符

## 在以下命令中，我们用 grep 搜索什么？：

grep '[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}' some_file

grep -E "error|failure" some_file

grep '[0-9]$' some_file


一个 IP 地址

单词 "error" 或 "failure"

以数字结尾的行

## 在以下内容上运行 `grep '\baaa\b'` 时，会打印哪些行号：

aaa bbb ccc.aaa aaaaaa


第 1 行和第 3 行。


什么是退出码？你熟悉哪些退出码？


退出码（或返回码）表示子进程返回给父进程的代码。


0 是表示成功的退出码，而大于 1 的任何值都表示错误。每个数字的含义都根据应用程序的开发方式而不同。



## 磁盘和文件系统

## 什么是 inode？


Linux 中的每个文件（和目录）都有一个 inode，它是一个存储文件相关元数据的数据结构，比如文件的大小、所有者、权限等。


## 以下哪一项不包含在 inode 中：

链接计数

文件大小

文件名

文件时间戳


文件名（它是目录文件的一部分）


## 如何检查哪些磁盘当前已挂载？


运行 mount 命令


## 你运行 mount 命令，但是没有输出。你怎么检查你的系统上有哪些挂载？


cat /proc/mounts


## 软链接和硬链接有什么区别？


硬链接是同一个文件，使用同一个 inode。软链接是指向另一个文件的快捷方式，使用不同的 inode。


## 对或错？你可以为一个目录创建一个硬链接


错


##对或错？你可以在不同的文件系统之间创建一个软链接


对


## 对或错？目录至少有 2 个链接


对。


## 如何创建一个

新的空文件

一个带有文本的文件（不使用文本编辑器）

一个指定大小的文件


touch new_file.txt

cat > new_file [enter] 输入文本；按 ctrl + d 退出插入模式

truncate -s new_file.txt


## 如何检查一个特定目录的大小？


du -sh


## 什么是 LVM？

LVM 是 Logical Volume Manager 的缩写，它是 Linux 系统中提供逻辑卷管理的一种技术。它可以让您把多个物理卷（硬盘或分区）组合成一个或多个逻辑卷，从而实现动态调整卷大小、分割或合并卷、移动卷等功能。


## 解释一下 LVM 中的以下概念：

PV

VG

LV


LVM 中的一些基本概念如下：


- PV (Physical Volume)：物理卷，是 LVM 的基本构建块，可以是一个硬盘或一个分区，它被 LVM 识别并用于存储数据。

- VG (Volume Group)：卷组，是由一个或多个物理卷组成的一个逻辑容器，它提供了一个统一的存储空间，可以在其中创建逻辑卷。

- LV (Logical Volume)：逻辑卷，是从卷组中分配的一个逻辑分区，它可以被格式化为文件系统，并挂载到目录上使用。逻辑卷的大小可以根据需要增加或减少，也可以在物理卷之间移动。


## 什么是 NFS？它有什么用？


NFS 是 Network File System 的缩写，它是一种分布式文件系统，可以让多台计算机通过网络共享文件。¹²³


NFS 的主要用途有：


- 实现文件共享，让不同的用户或应用程序可以访问同一份数据，方便协作和同步。

- 实现存储集中化，让多台计算机可以使用同一个存储服务器，节省硬件成本和管理成本。

- 实现负载均衡，让多台计算机可以同时读写同一个文件，提高性能和可靠性。


## RAID 有什么用？你能解释一下 RAID 0, 1, 5 和 10 的区别吗？


RAID 是 Redundant Array of Independent Disks 的缩写，它是一种通过将多个独立的硬盘驱动器组合成一个协调的存储单元或阵列，从而创建数据冗余或提高性能的技术。¹³¹⁴¹⁵


## RAID 的主要用途有：


- 实现数据冗余，让数据可以被复制或分散在多个硬盘上，从而提高数据的可靠性和容错性。

- 实现性能提升，让数据可以被并行地读写在多个硬盘上，从而提高数据的吞吐量和响应速度。

- 实现存储扩展，让多个小容量的硬盘可以组合成一个大容量的存储空间，从而满足数据的增长需求。


RAID 有多种不同的级别，常见的有 RAID 0, 1, 5, 10 等，它们的区别如下：


- RAID 0：条带化，将数据平均分成多个块，按顺序分布在多个硬盘上，没有数据冗余，提高了读写性能，但降低了数据安全性，任何一个硬盘损坏都会导致数据丢失。

- RAID 1：镜像，将数据完全复制在两个或多个硬盘上，实现了数据冗余，提高了数据安全性和读取性能，但降低了存储效率，只有一半的有效容量。

- RAID 5：分布式奇偶校验，将数据和校验信息分布在三个或多个硬盘上，实现了数据冗余和性能提升，但降低了写入性能，可以容忍一个硬盘损坏。

- RAID 10：镜像+条带化，将多个 RAID 1 的组合再进行 RAID 0 的条带化，实现了数据冗余和性能提升，但降低了存储效率，需要至少四个硬盘，可以容忍一半的硬盘损坏。


## 描述一下扩展文件系统磁盘空间的过程



扩展文件系统磁盘空间的过程，一般分为以下几个步骤：


- 如果是物理磁盘，可以使用 fdisk 或 parted 等工具对磁盘进行分区，创建新的分区或扩展现有的分区。

- 如果是逻辑卷，可以使用 LVM 的命令，如 pvcreate, vgextend, lvextend 等，对物理卷，卷组，逻辑卷进行扩展。

- 如果是文件系统，可以使用 resize2fs, xfs_growfs 等工具，根据不同的文件系统类型，对文件系统进行在线或离线的扩展。


## 什么是 lazy umount？


lazy umount 是一种卸载文件系统的方式，它可以在文件系统还被占用的情况下，将文件系统从目录树中分离，等到文件系统不再被占用时，再真正地卸载文件系统。


lazy umount 的主要用途有：


- 避免因为文件系统被占用而无法卸载的情况，比如有进程正在访问文件系统中的文件，或者有用户正在工作目录下。

- 实现文件系统的无缝切换，比如在更新软件或配置时，可以先 lazy umount 旧的文件系统，再 mount 新的文件系统，然后让进程重新打开文件，实现平滑过渡。

- 实现文件系统的延迟卸载，比如在不确定文件系统是否还有用时，可以先 lazy umount 文件系统，等到文件系统不再被使用时，再自动卸载，节省资源。


## 什么是 tmpfs？


tmpfs 是一种基于内存的文件系统，它将所有的文件存储在内存或交换分区中，不占用硬盘空间。


tmpfs 的主要用途有：


- 实现文件的快速读写，利用内存的高速性能，提高文件的访问速度，比如 /dev/shm, /run 等目录就是使用 tmpfs。

- 实现文件的自动清理，利用内存的易失性，实现文件的临时存储，比如 /tmp 等目录就可以使用 tmpfs，重启后文件会自动消失。

- 实现文件的动态调整，利用内存的灵活性，实现文件系统的大小根据使用情况自动增减，比如 tmpfs 的默认大小是内存的一半，但是只有真正使用时才会占用内存。


## 以下日志中分别存储了什么？

/var/log/messages

/var/log/boot.log

/var/log/messages 文件是一个重要的日志文件，它记录了各种程序和服务的消息，包括内核的消息，系统的错误消息，系统的启动和关闭消息，网络配置的变化消息等。¹⁶¹⁷ 这是在出现问题时，首先要查看的日志文件。


/var/log/boot.log 文件是一个启动日志文件，它记录了系统启动时的服务加载情况，包括服务的名称，进程号，启动结果等。[^20^] ²¹ 这是在检查系统启动是否正常时，要查看的日志文件。



## 对或错？/tmp 和 /var/tmp 在系统启动时都会被清空


错。/tmp 在系统启动时会被清空，而 /var/tmp 会每隔几天清空一次，或者根本不清空（取决于发行版）



##性能分析

##如何检查当前的平均负载？


可以使用 uptime 或 top 命令


##每个部分都代表什么意思？例如 1.43, 2.34, 2.78


这篇文章很好地总结了平均负载的主题


##如何检查进程的使用情况？


pidstat 命令


##如何检查磁盘 I/O？


iostat -xz 1 命令


##如何检查系统有多少空闲内存？如何检查每个进程的内存消耗？


可以使用 top 和 free 命令


##如何检查 TCP 统计信息？


sar -n TCP,ETCP 1 命令



## 进程

## 如何列出系统中运行的所有进程？


可以使用 "ps" 命令来列出系统中运行的所有进程。"ps aux" 命令提供了所有进程的详细列表，包括在后台运行的进程。


## 如何在后台运行一个进程，以及为什么要这样做？


可以在命令的末尾加上 & 符号来实现。至于为什么，因为有些命令/进程可能需要很长时间才能完成执行或者永远运行，你可能想要在后台运行它们，而不是等待它们完成后再获得当前会话的控制权。


## 你如何找出一个特定进程消耗了多少内存？



mem()

{                                                                                                      

    ps -eo rss,pid,euser,args:100 --sort %mem | grep -v grep | grep -i $@ | awk '{printf $1/1024 "MB"; $1=""; print }'

}

## 当你运行 'kill *process id*' 时，默认使用的是什么信号？


默认使用的信号是 SIGTERM (15)。这个信号优雅地终止进程，也就是说它允许进程保存当前的状态配置。

## 你熟悉哪些信号？


SIGTERM - 终止进程的默认信号 SIGHUP - 常用于重新加载配置 SIGKILL - 不能被捕获或忽略的信号


要查看所有可用的信号，运行 kill -l 命令


## kill 0 会做什么？


"kill 0" 会向当前进程组中的所有进程发送一个信号。它用于检查进程是否存在。

## kill -0 会做什么？


"kill -0" 会检查一个给定的进程 ID 是否存在。它实际上不会向进程发送任何信号。

## 什么是 trap？


trap 是一种机制，它允许 shell 拦截发送给进程的信号，并执行一个特定的动作，比如在终止进程之前处理错误或清理资源。


## 每隔几天，有一个进程就停止运行了。你怎么查找原因？


查找进程停止运行的原因的一种方法是检查系统日志，比如 /var/log/messages 或 journalctl 中的消息。另外，检查进程的资源使用情况和系统负载也可能提供一些线索。

## 当你按 ctrl + c 时会发生什么？


当你按 "Ctrl+C" 时，它会向前台进程发送 SIGINT 信号，要求它优雅地终止。

## 什么是 Linux 中的守护进程？


一个后台进程。这些进程大多数都在等待请求或一组条件满足后才真正运行。一些例子：sshd, crond, rpcbind。


## Linux 中的进程有哪些可能的状态？


运行中 (R)

不可中断睡眠 (D) - 进程在等待 I/O

可中断睡眠 (S)

停止 (T)

死亡 (x)

僵尸 (z)

## 如何杀死一个处于 D 状态的进程？


一个处于 D 状态（也称为“不可中断睡眠”）的进程不能使用 "kill" 命令杀死。终止它的唯一方法是重启系统。

## 什么是僵尸进程？


一个已经运行结束但没有退出的进程。


它发生的一个原因是父进程编程不正确。每个父进程都应该执行 wait() 来获取运行结束的子进程的退出码。但是当父进程没有检查子进程的退出码时，子进程就可能虽然运行结束了，但仍然存在。


##如何消除僵尸进程？


你不能用 kill -9 这样的常规方法杀死一个僵尸进程，因为它已经死了。


杀死僵尸进程的一种方法是向父进程发送 SIGCHLD 信号，告诉它终止它的子进程。如果父进程没有正确地编程，这可能不会起作用。调用的方式是 kill -s SIGCHLD [parent_pid]


你也可以尝试关闭/终止父进程。这会使僵尸进程成为 init (1) 的子进程，它会定期清理，并且在某个时候清理僵尸进程。


如何找到所有的

由某个用户执行/拥有的进程

是 Java 进程的进程

僵尸进程


如果你在任何地方提到 ps 命令和参数，要熟悉这些参数的确切含义。


##什么是 init 进程？


它是系统启动时内核执行的第一个进程。它是一个守护进程，它运行到系统关闭为止。这就是为什么，它是所有进程的父进程。

你能描述一下进程是如何被创建的吗？


##如何改变一个进程的优先级？你为什么要这样做？


要改变一个进程的优先级，你可以在 Linux 中使用 nice 命令。nice 命令允许你通过分配一个从 -20 到 19 的优先值来指定一个进程的优先级。优先值越高，进程的优先级越低，反之亦然。

你可能想要改变一个进程的优先级，以调整它被系统调度器分配的 CPU 时间。例如，如果你的系统上有一个占用 CPU 的进程，导致其他进程变慢，你可以降低它的优先级，给其他进程更多的 CPU 时间。


##你能解释一下网络进程/连接是如何建立和终止的吗？


当一个系统上的客户端进程想要与另一个系统上的服务器进程建立连接时，它首先使用 socket 系统调用创建一个套接字。客户端然后调用 connect 系统调用，将服务器的地址作为参数传递。这会导致客户端和服务器之间发生三次握手，其中两个系统交换信息来建立连接。

一旦连接建立，客户端和服务器就可以使用 read 和 write 系统调用来交换数据。当连接不再需要时，客户端或服务器可以通过在套接字上调用 close 系统调用来终止连接。


##strace 做什么？ltrace 呢？


strace 是一个调试工具，用于监控一个进程所做的系统调用。它允许你跟踪一个进程的执行，看到它所做的系统调用，以及它收到的信号。这对于诊断进程的问题很有用，比如识别它为什么挂起或崩溃。

ltrace，另一方面，是一个类似的工具，用于跟踪一个进程所做的库调用。它允许你看到一个进程对共享库所做的函数调用，以及传递给这些函数的参数。这对于诊断涉及库调用的进程的问题很有用，比如识别为什么一个特定的库会导致问题。



找到所有以 '.yml' 结尾的文件，并将每个文件中的数字 1 替换为 2


find /some_dir -iname *.yml -print0 | xargs -0 -r sed -i "s/1/2/g"


##你运行 ls，你得到 "/lib/ld-linux-armhf.so.3 no such file or directory"。这是什么问题？


ls 可执行文件是为不兼容的架构构建的。


你如何将一个 50 行的文件分成两个 25 行的文件？


你可以这样使用 split 命令：split -l 25 some_file


## 什么是文件描述符？你熟悉哪些文件描述符？


文件描述符，也称为文件句柄，是一个唯一的数字，用于在操作系统中标识一个打开的文件。

在 Linux（和 Unix）中，前三个文件描述符是：


0 - 输入的默认数据流

1 - 输出的默认数据流

2 - 与错误相关的输出的默认数据流

这是一篇关于这个主题的很好的文章：[https://www.computerhope.com/jargon/f/file-descriptor.htm](https://www.computerhope.com/jargon/f/file-descriptor.htm)


## 什么是 NTP？它有什么用？


NTP 是 Network Time Protocol 的缩写，它是一种用于同步网络中计算机的时间的协议。


NTP 的主要用途有：


- 实现时间一致性，让网络中的计算机都使用相同的时间标准，避免时间差异造成的问题。

- 实现时间精确性，让网络中的计算机都使用高精度的时间源，比如原子钟，校正时间的误差和漂移。

- 实现时间安全性，让网络中的计算机都使用加密和认证的方式，防止时间被篡改或伪造。


## 解释一下内核 OOM


内核 OOM 是 Kernel Out Of Memory 的缩写，它是一种内核在内存不足时的处理机制。


## 内核 OOM 的主要原理是：


- 当内核检测到内存不足时，它会触发 OOM Killer，一种负责杀死占用内存最多的进程的程序。

- OOM Killer 会根据每个进程的 OOM Score，一种表示进程对内存的重要性和消耗的评分，来选择要杀死的进程。

- OOM Killer 会尽量避免杀死系统关键的进程，比如 init，或者用户交互的进程，比如 shell。

- OOM Killer 会尽量杀死那些释放内存最多的进程，比如占用大量内存的应用程序或服务。

- OOM Killer 会在系统日志中记录它杀死的进程的信息，以便用户或管理员进行分析和调整。


## 安全

## 什么是 chroot？您在什么情况下会考虑使用它？


chroot 是一种在 Linux 中改变根目录的方法，它可以让一个进程和它的子进程在一个隔离的环境中运行，而不受外部的影响。它可以用于测试、调试、恢复、安全等场景。


## 什么是 SELinux？


SELinux 是一种基于策略的强制访问控制系统，它可以增强 Linux 的安全性，防止未授权的访问和操作。它可以根据预定义的规则，对进程、文件、端口等进行标记和控制。


## 什么是 Kerberos？


Kerberos 是一种网络认证协议，它可以在不安全的网络中提供安全的身份验证和授权。它使用对称密钥加密和票据交换的机制，来保证通信的机密性和完整性。


## 什么是 nftables？


nftables 是一种新的 Linux 内核的包过滤框架，它可以替代 iptables 和其他相关的工具。它提供了一个统一的语法和接口，来管理不同的协议和层次的包过滤规则。


## firewalld 守护进程负责什么？


firewalld 是一种 Linux 的动态防火墙管理器，它可以实时地修改防火墙的配置，而不需要重启服务或断开连接。它使用 zones 和 services 的概念，来定义不同的网络环境和应用程序的访问权限。


## 您有硬化服务器的经验吗？您能描述一下过程吗？


硬化服务器是指通过一系列的配置和优化，来提高服务器的安全性和性能的过程。具体的步骤可能因不同的服务器和需求而异，但一般包括以下几个方面：


- 更新系统和软件，修复已知的漏洞和错误

- 删除不必要的服务和程序，减少攻击面

- 配置合理的用户和权限，限制对敏感数据和资源的访问

- 启用防火墙和 SELinux，设置合适的包过滤和访问控制规则

- 使用加密和认证，保护通信和数据的安全

- 监控和审计，记录和分析系统的活动和异常


## 您如何为 CA (证书颁发机构) 创建一个私钥？


一种方法是使用 openssl 这样：


openssl genrsa -aes256 -out ca-private-key.pem 4096


## 您如何为 CA (证书颁发机构) 创建一个公钥？


openssl req -new -x509 -days 730 -key [私钥文件名] -sha256 -out ca.pem


如果使用前一个问题的私钥，那么命令就是：


openssl req -new -x509 -days 730 -key ca-private-key.pem -sha256 -out ca.pem


演示一种在 Linux 中编码和解码数据的方法


编码：echo -n "some password" | base64 解码：echo -n "allE19remO91" | base64



## 网络

##  如何列出所有的接口？


ip link show


## 什么是回环 (lo) 接口？


回环接口是一种特殊的虚拟网络接口，您的计算机用它来与自己通信。它主要用于诊断和故障排除，以及连接到本地机器上运行的服务器。


## 以下命令分别用于什么？

ip addr

ip route

ip link

ping

netstat

traceroute


ip addr 用于显示或修改网络接口的地址信息

ip route 用于显示或修改路由表

ip link 用于显示或修改网络接口的状态和属性

ping 用于测试网络连通性，发送和接收 ICMP 回显请求和回复

netstat 用于显示网络连接，路由表，接口统计，套接字等信息

traceroute 用于追踪数据包在网络中的路径，显示每个跳转点的延迟和丢包情况


## 什么是网络命名空间？它有什么用途？


网络命名空间是一种 Linux 的特性，它可以让不同的进程拥有独立的网络环境，例如接口，地址，路由，防火墙等。它可以用于实现网络的隔离，虚拟化，沙箱等功能。


## 如何检查某个端口是否被占用？


以下方法之一可以工作：


netstat -tnlp | grep <port_number>

lsof -i -n -P | grep <port_number>


## 您如何将您的 Linux 服务器变成一个路由器？


一种方法是启用网络转发功能，让服务器可以转发不同接口的数据包。例如，如果您想让 eth0 和 eth1 之间的数据包可以互相转发，您可以执行以下命令：


echo 1 > /proc/sys/net/ipv4/ip_forward

iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

iptables -A FORWARD -i eth0 -o eth1 -m state --state RELATED,ESTABLISHED -j ACCEPT

iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT


## 什么是虚拟 IP？您在什么情况下会使用它？


虚拟 IP 是一种不绑定在特定接口或设备上的 IP 地址，它可以在多个接口或设备之间动态切换，提供高可用性和负载均衡。您可以在需要保证服务的连续性和性能的情况下使用它，例如集群，负载均衡，故障转移等。


## 对或错？接口的 MAC 地址是由操作系统分配/设置的


错


## 您可以在一个系统中有多个默认网关吗？


从技术上讲，是的。


## 什么是 telnet，为什么在生产环境中使用它是一个坏主意？（或者根本不用）


Telnet 是一种客户端-服务器协议，它可以用于在远程计算机上打开一个命令行，通常是一个服务器。默认情况下，通过 telnet 发送和接收的所有数据都是以明文/纯文本的形式传输的，因此它不应该被使用，因为它不会加密客户端和服务器之间的任何数据。


## 什么是路由表？您如何查看它？


路由表是一种存储路由信息的数据结构，它指示数据包如何从一个网络到达另一个网络。您可以使用 ip route 命令来查看路由表。


## 您如何从您的 shell 发送一个 HTTP 请求？


使用 nc 是一种方法，例如：


echo -e "GET / HTTP/1.1\r\nHost: [www.example.com\r\n\r\n](https://www.example.com\r\n\r\n)" | nc [www.example.com](https://www.example.com) 80



## 什么是包嗅探器？您过去有没有使用过？如果是，您使用过哪些包嗅探器，以及为了什么目的？


包嗅探器是一种网络工具，它可以分析和可能注入到目标网络上的数据流中的任务。它可以用于监控，调试，测试，攻击等场景。

我过去使用过一些包嗅探器，例如 tcpdump，wireshark，nmap 等。我用它们来捕获和分析网络上的数据包，查看协议，端口，地址，内容等信息。


## 如何列出活动的连接？


一种方法是使用 ss 命令，它可以显示套接字的状态和详细信息。例如，ss -t -a 可以列出所有的 TCP 连接，ss -u -a 可以列出所有的 UDP 连接。


## 如何触发 IPv6 的邻居发现？


一种方法是使用 ping6 ff02::1 命令，它可以向所有的本地链路节点发送一个 ICMPv6 回显请求，从而触发邻居发现的过程。


## 什么是网络接口绑定，您知道它在 Linux 中是如何实现的吗？


网络接口绑定是一种将多个物理或虚拟的网络接口组合成一个逻辑的网络接口的方法，它可以提高网络的带宽，可靠性，容错性等。在 Linux 中，它可以通过使用 bonding 模块和配置文件来实现。


## 网络绑定有哪些模式？


有几种模式：


balance-rr: 轮询绑定，按顺序分配数据包到每个接口

active-backup: 容错绑定，只有一个接口处于活动状态，其他的作为备份

balance-tlb: 自适应传输负载均衡，根据接口的负载和速度动态分配数据包

balance-alb: 自适应负载均衡，类似于 balance-tlb，但是还可以接收负载均衡


## 什么是桥接？它在 Linux 系统中是如何添加的？


桥接是一种将多个网络接口连接到同一个网络的方法，它可以实现网络的隔离，虚拟化，转发等功能。在 Linux 系统中，它可以通过使用 bridge-utils 包和配置文件来添加。例如，brctl addbr br0 可以创建一个名为 br0 的桥接，brctl addif br0 eth0 可以将 eth0 接口添加到 br0 桥接中。



## DNS

## 如何检查系统的主机名？


cat /etc/hostname


您也可以运行 hostnamectl 或 hostname，但这可能只会打印一个临时的主机名。文件中的那个是永久的。


/etc/resolv.conf 文件用于什么？它包含什么？


/etc/resolv.conf 文件用于配置 DNS 解析器，它包含了一个或多个 DNS 服务器的 IP 地址，以及一些可选的参数，如域名、搜索域和超时时间等。


## 您使用什么命令来执行 DNS 查询（或排查 DNS 相关的问题）？


您可以指定以下一个或多个命令：


dig

host

nslookup

## 您运行 dig codingshell.com 并得到以下结果：

ANSWER SECTION:

codingshell.com.	3515	IN	A	185.199.109.153

数字 3515 的含义是什么？


这是 TTL（生存时间）。当您使用域名/主机名查找一个地址时，您的操作系统会通过联系 DNS 名称服务器来获取您要查找的主机/域的 IP 地址。

当您得到一个回复时，这个回复会在您的操作系统中缓存一段时间。这段时间也被称为 TTL，这就是 3515 这个数字的含义 - 它会在缓存中保留 3515 秒，然后从缓存中删除，在这段时间内，您会从缓存中获取值，而不是再次向 DNS 名称服务器请求地址。


## 如何通过 `nmcli` 命令修改网络连接，使用 `8.8.8.8` 作为 DNS 服务器？


找到连接名称：


$ nmcli con show

NAME         UUID                                  TYPE      DEVICE

System ens5  8126c120-a964-e959-ff98-ac4973344505  ethernet  ens5

System eth0  5fb06bd0-0bb0-7ffb-45f1-d6edd65f3e03  ethernet  --

这里的连接名称是 "System ens5"。假设我们想要修改这个连接的设置。


修改连接，使用 8.8.8.8 作为 DNS 服务器：


$ nmcli con mod "System ens5" ipv4.dns "8.8.8.8"

我们需要重新激活连接，使更改生效：


nmcli con up "System ens5"

再次验证我们的设置：


cat /etc/resolv.conf

nmcli -f ipv4.dns con show "System ens5"


## 打包

您有打包的经验吗？（指的是构建软件包）您能解释一下它是如何工作的吗？


打包是指将软件的源代码或二进制文件，以及一些元数据（如名称、版本、描述、依赖关系等）打包成一个文件，以便于分发和安装。不同的操作系统或发行版可能有不同的打包格式和工具，例如 RPM、DEB、TAR.GZ 等。


您在您使用的发行版上如何安装/卸载软件包？


答案取决于您使用的发行版。


在 Fedora/CentOS/RHEL/Rocky 上，可以使用 rpm 或 dnf 命令。在 Ubuntu 上，可以使用 apt 命令。


RPM: 解释一下 spec 格式（它应该和可以包含什么）


spec 文件是 RPM 打包的核心，它定义了如何构建一个 RPM 软件包。它包含了以下几个部分：


- Preamble: 包含了软件包的基本信息，如名称、版本、发布号、许可证、摘要、描述等。

- Preparation: 包含了准备构建所需的命令，如下载、解压、打补丁等。

- Build: 包含了实际构建软件的命令，如编译、链接等。

- Install: 包含了将构建好的软件安装到一个临时目录的命令，以便于打包。

- Clean: 包含了清理构建过程中产生的临时文件的命令。

- Files: 列出了软件包中包含的文件和目录，以及它们的属性和权限。

- Changelog: 记录了软件包的更新历史和变更日志。

- Scripts: 包含了在软件包安装、卸载或升级时执行的脚本，如 pre-install, post-install, pre-uninstall, post-uninstall 等。

- Triggers: 定义了在其他软件包安装、卸载或升级时触发的动作，如重新加载配置、重启服务等。

- Sources: 列出了软件包所需的源文件，如源代码、补丁、图标等。

- Patches: 列出了软件包所需的补丁文件。

- BuildRequires: 列出了构建软件包所需的依赖关系。

- Requires: 列出了运行软件包所需的依赖关系。


## 如何在不实际安装的情况下列出软件包的内容？


可以使用 rpm -qlp 命令，后面跟上软件包的文件名，例如：


rpm -qlp httpd-2.4.37-30.module_el8.4.0+886+c9a8d9ad.x86_64.rpm


## 如何知道系统上的一个文件属于哪个软件包？如果它不属于任何软件包，会有什么问题？


可以使用 rpm -qf 命令，后面跟上文件的路径，例如：


rpm -qf /usr/bin/git


如果一个文件不属于任何软件包，可能意味着它是手动安装或复制的，或者是由其他程序生成的。这可能会导致以下问题：


- 难以追踪文件的来源和版本。

- 难以管理文件的更新和卸载。

- 可能与软件包管理器维护的文件发生冲突或覆盖。

- 可能破坏系统的一致性和安全性。


## 仓库存储在哪里？（根据您使用的发行版）


仓库是指存储软件包的服务器或目录，软件包管理器可以从中获取和安装软件包。不同的发行版可能有不同的仓库位置和格式，例如：


- 在 Fedora/CentOS/RHEL/Rocky 上，仓库的配置文件存储在 /etc/yum.repos.d 目录下，每个文件定义了一个或多个仓库的 URL、名称、优先级、签名等信息。

- 在 Ubuntu 上，仓库的配置文件存储在 /etc/apt/sources.list 文件或 /etc/apt/sources.list.d 目录下，每行定义了一个仓库的 URL、分发、组件等信息。


## 什么是归档？您如何在 Linux 中创建一个归档？


归档是指将多个文件或目录打包成一个文件，以便于存储和传输。在 Linux 中，有多种工具可以用来创建归档，例如：


- tar: 可以创建和解压 .tar、.tar.gz、.tar.bz2、.tar.xz 等格式的归档。常用的选项有 c (创建)、x (解压)、z (gzip 压缩)、j (bzip2 压缩)、J (xz 压缩)、v (显示详细信息)、f (指定文件名) 等。例如：


  - 创建一个 .tar 归档：tar cvf archive.tar file1 file2 dir1

  - 创建一个 .tar.gz 归档：tar czvf archive.tar.gz file1 file2 dir1

  - 解压一个 .tar 归档：tar xvf archive.tar

  - 解压一个 .tar.gz 归档：


## 为什么我们需要包管理器？为什么不直接创建归档文件并发布它们？


包管理器允许你管理包的生命周期，比如安装、删除和更新包。

另外，你还可以在一个规范文件中指定一个包如何安装 - 把文件复制到哪里，安装前后运行哪些命令，等等。


## DNF

## DNF 是什么？


从仓库中的描述：


“DNF 是 YUM 的下一个主要版本。它使用 RPM，libsolv 和 hawkey 库进行包管理。”


## 如何查找提供 /usr/bin/git 命令的包？（该包不一定已经安装）


dnf provides /usr/bin/git



## 应用程序和服务

在 /etc/services 中可以找到什么？


在 /etc/services 中可以找到各种网络服务和它们对应的端口号和协议类型。这个文件是一个文本文件，每一行包含一个服务的名称，端口号，协议类型和可选的注释。例如：


ssh             22/tcp          # Secure Shell

http            80/tcp          # World Wide Web HTTP

https           443/tcp         # HTTP protocol over TLS/SSL



## 如何确保一个服务在重启或崩溃后自动启动？


这取决于使用的初始化系统。


Systemd:  systemctl enable [service_name]  # 启用一个服务

System V:  update-rc.d [service_name]  # 更新一个服务的运行级别，并在 /etc/inittab 中添加这一行  id:5678:respawn:/bin/sh /path/to/app  # 设置一个服务在终止后自动重启

Upstart: 在 /etc/init/service.conf 中添加 Upstart 初始化脚本 # 定义一个服务的启动条件和行为



## 你运行 ssh 127.0.0.1，但是失败了，提示“连接拒绝”。可能是什么问题？


可能有以下几种原因：


SSH 服务器没有安装

SSH 服务器没有运行

SSH 服务器的端口不是默认的 22

SSH 服务器的配置文件中禁止了本地连接

SSH 服务器的防火墙或 SELinux 等安全机制阻止了连接



## 如何打印一个程序所需的共享库？这有什么用处？


有几种方法可以打印一个程序所需的共享库，最常用的是 ldd 命令。ldd 命令会输出一个程序或共享对象依赖的所有共享库，以及它们的路径和地址。例如：


$ ldd /bin/ls

	linux-vdso.so.1 (0x00007ffe5f9f8000)

	libselinux.so.1 => /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f7a6f9c9000)

	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7a6f5d8000)

	libpcre.so.3 => /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f7a6f366000)

	libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f7a6f162000)

	/lib64/ld-linux-x86-64.so.2 (0x00007f7a6fc0a000)

	libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f7a6ef43000)


打印一个程序所需的共享库有以下用处：


可以检查一个程序是否缺少某些共享库，或者是否加载了错误的版本

可以分析一个程序的性能和内存占用，以及优化它的链接方式

可以调试一个程序的运行时错误，比如段错误或符号未定义等



## CUPS 是什么？


CUPS（原名 Common UNIX Printing System）是一个用于类 Unix 操作系统的模块化打印系统，它可以让一个计算机充当打印服务器。一个运行 CUPS 的计算机可以接收来自其他计算机的打印任务，处理它们，并把它们发送到适当的打印机。CUPS 包括一个打印队列和调度器，一个过滤系统，它可以把打印数据转换成打印机能理解的格式，以及一个后端系统，它可以把数据发送到打印设备。CUPS 使用 Internet Printing Protocol（IPP）作为管理打印任务和队列的基础。它也提供了传统的命令行接口，用于 System V 和 Berkeley 打印系统，并支持 Berkeley 打印系统的 Line Printer Daemon 协议和有限的 Server Message Block（SMB）协议。系统管理员可以通过编辑 Adobe 的 PostScript Printer Description（PPD）格式的文本文件来配置 CUPS 提供的设备驱动。CUPS 还有一些不同平台的用户界面，可以用来配置 CUPS，以及一个内置的基于 web 的界面。CUPS 是自由软件，遵循 Apache License 2.0 许可协议。



## 你熟悉哪些类型的 web 服务器？


web 服务器是一种用于处理和响应 web 请求的软件或硬件。web 服务器可以提供静态或动态的 web 内容，比如 HTML 页面，图片，脚本，应用程序等。web 服务器通常使用 HTTP 协议，但也可以支持其他协议，比如 HTTPS，FTP，SMTP 等。我熟悉以下几种类型的 web 服务器：


Nginx: 一个高性能的开源 web 服务器，支持反向代理，负载均衡，缓存，压缩，安全等功能。Nginx 也可以作为邮件代理或 TCP/UDP 代理。

Apache httpd: 一个流行的开源 web 服务器，支持多种模块，可以扩展其功能和性能。Apache httpd 也支持虚拟主机，重写，认证，SSL 等功能。



## 您知道如何在不使用 adduser/useradd 命令的情况下创建一个新用户吗？


是的，我们可以通过手动在 /etc/passwd 文件中添加一个条目来创建新用户。


例如，如果我们需要创建一个叫 john 的用户。


步骤 1：在 /etc/passwd 文件中添加一个条目，这样用户就创建了。


echo "john:x:2001:2001::/home/john:/bin/bash" >> /etc/passwd


步骤 2：在 /etc/group 文件中添加一个条目，因为每个用户都属于与用户名相同的主组。


echo "john:x:2001:" >> /etc/group


步骤 3：验证用户是否创建成功


id john


## /etc/passwd 中存储了哪些信息？解释每个字段


/etc/passwd 是一个包含用户信息的配置文件，这个文件中的每个条目有 7 个字段，


username:password:UID:GID:Comment:home directory:shell


username - 用户的名字。


password - 这个字段实际上是密码字段的占位符。出于安全考虑，这个字段不包含密码，只是一个占位符 (x)，指向 /etc/shadow 文件中存储的加密密码。


UID - 用户的用户 ID。


GID - 用户的组 ID。


Comment - 这个字段是为了提供关于用户的描述。


home directory - 用户的主目录的绝对路径。这个目录在用户添加时创建。


shell - 这个字段包含用户将要使用的 shell 的绝对路径。


## 如何在不给他提供登录系统的能力的情况下，向系统添加一个新用户？


adduser user_name --shell=/bin/false --no-create-home 您也可以添加一个用户，然后编辑 /etc/passwd。


## 如何切换到另一个用户？如何切换到 root 用户？


使用 su 命令。使用 su - 来切换到 root。


## root 用户的 UID 是多少？普通用户呢？


root 用户的 UID 是 0


/etc/login.defs 中 UID_MIN 和 UID_MAX 的默认值 UID_MIN 是 1000 UID_MAX 是 60000


实际上，我们可以改变这个值。但是 UID < 1000 是为系统账户保留的。因此，根据默认配置，对于普通用户，UID 从 1000 开始。


## /etc/skel 是什么？


/etc/skel 是一个目录，它包含了一些文件或目录，所以当一个新用户被创建时，这些在 /etc/skel 中创建的文件/目录会被复制到用户的主目录中。


## 如何查看谁登录了系统的列表？


使用 last 命令。


解释以下命令分别做什么：

useradd

usermod

whoami

id


useradd - 用于创建新用户的命令 usermod - 修改用户设置的命令 whoami - 输出我们当前登录的用户名 id - 打印用户的 UID，GID，和所属的组


## 您运行 grep $(whoami) /etc/passwd，但是输出为空。这可能是什么原因？


您使用的用户不是本地定义的，而是来自像 LDAP 这样的服务。

您可以用 getent passwd 来验证。



## 硬件

## 您在哪里可以找到关于处理器（比如 CPU 数量）的信息？


/proc/cpuinfo


## 您也可以使用 nproc 来查看处理器的数量


## 您如何打印 BIOS，主板，处理器和 RAM 的信息？


dmidecode


## 您如何打印系统中连接的所有块设备的信息？


lsblk


## 对或错？在用户空间，应用程序没有完全访问硬件资源的权限


对。只有在内核空间，它们才有完全访问硬件资源的权限。”


## /proc/meminfo 中的 MemFree 和 MemAvailable 有什么区别？


MemFree - 系统中未使用的物理 RAM 的数量 MemAvailable - 基于 MemFree、Active(file)、Inactive(file) 和 SReclaimable，新工作负载可用的内存量（不会导致系统使用交换分区）


## 命名空间

## Linux 中有哪些类型的命名空间？


进程 ID 命名空间：这些命名空间包含独立的一组进程 ID

挂载命名空间：隔离和控制挂载点

网络命名空间：隔离系统网络资源，如路由表、接口、ARP 表等

UTS 命名空间：隔离主机和域

IPC 命名空间：隔离进程间通信

用户命名空间：隔离用户和组 ID

时间命名空间：隔离时间机器

## 判断正误？在每个 PID（进程 ID）命名空间中，第一个分配的进程 ID 号为 1


正确。在命名空间内，它的 PID 为 1，而对于父命名空间，PID 是不同的。


## 判断正误？在子 PID 命名空间中，所有进程都能感知父 PID 命名空间和进程，而父 PID 命名空间无法看到子 PID 命名空间的进程


错误。正好相反。父 PID 命名空间能够感知并查看子 PID 命名空间中的进程，而子 PID 命名空间无法看到父 PID 命名空间中发生的事情。


## 判断正误？默认情况下，当创建两个独立的网络命名空间时，从一个命名空间向另一个命名空间发送 ping 将正常工作


错误。网络命名空间有自己的接口和路由表。没有办法（例如，没有创建桥接）让一个网络命名空间到达另一个网络命名空间。


## 判断正误？使用 UTS 命名空间，进程可能看起来像是在不同的主机和域上运行，而实际上是在同一台主机上运行


正确


## 判断正误？在子用户命名空间中，不可能有 ID 为 0 的根用户


错误。在每个子用户命名空间中，都可以有一个 ID 为 0 的单独根用户。


## 时间命名空间用于什么？


在时间命名空间中，进程可以使用不同的系统时间


## 虚拟化

## Linux 有哪些虚拟化解决方案？


KVM

XEN

VirtualBox

Linux-VServer

User-mode Linux


## KVM 是什么？


是一种用于在 x86 硬件上运行的开源虚拟化技术。



## Libvirt 是什么？


它是一个用于管理虚拟机的开源软件集合。它可以与 KVM、Xen、LXC 等一起使用。它也被称为 Libvirt 虚拟化 API


## AWK

## awk 命令是做什么的？你用过吗？用来做什么？


从维基百科：“AWK 是一种专用于文本处理的领域特定语言，通常用作数据提取和报告工具”


## 如何打印文件中的第四列？


`awk '{print $4}' file`


## 如何打印每一行长度超过 79 个字符的行？


`awk 'length($0) > 79' file`


## lsof 命令是做什么的？你用过吗？用来做什么？


lsof 命令是用来列出打开的文件和进程的。它可以显示文件的类型、访问模式、用户、进程 ID 等信息。我用过它来查看哪些进程占用了某个端口或文件。


## find 和 locate 有什么区别？


find 命令是用来在文件系统中搜索文件或目录的。它可以根据名称、大小、类型、权限、所有者等条件进行过滤。locate 命令是用来在一个数据库中搜索文件或目录的。它比 find 命令更快，但是它依赖于数据库的更新，所以可能不会显示最新的结果。


## 用户进程如何执行特权操作，例如从磁盘读取？


用户进程通过使用系统调用来执行特权操作。系统调用是一种让用户进程请求内核服务的机制。内核会在特权模式下执行相应的操作，并返回结果给用户进程。


## 文件系统和文件

## 如何创建一个指定大小的文件？


有几种方法可以做到这一点：


dd if=/dev/urandom of=new_file.txt bs=2MB count=1

truncate -s 2M new_file.txt

fallocate -l 2097152 new_file.txt

##以下代码块的作用是什么？：

open("/my/file") = 5

read(5, "file content")


这些系统调用是读取文件 /my/file，而 5 是文件描述符号。


## 描述三种不同的删除文件（或其内容）的方法


- 使用 rm 命令删除文件，例如 rm new_file.txt

- 使用 shred 命令安全地删除文件，例如 shred -u new_file.txt

- 使用 > 重定向符号清空文件内容，例如 > new_file.txt


## 进程和线程有什么区别？


- 进程是一个执行中的程序的实例，它有自己的地址空间、资源和状态

- 线程是进程内的一个执行单元，它共享进程的地址空间、资源和状态，但有自己的栈、寄存器和程序计数器



## 什么是上下文切换？


从维基百科：上下文切换是保存一个进程或线程的状态，以便在以后的某个时刻恢复并继续执行的过程


## 您发现有一台服务器的 CPU 负载很高，但您没有找到一个 CPU 占用率高的进程。这怎么可能？


- 有可能是多个进程或线程同时占用 CPU，导致总体负载高，但没有单个进程或线程突出

- 有可能是 CPU 负载高是由于中断、系统调用或内核线程造成的，这些在普通的进程列表中不可见

- 有可能是 CPU 负载高是由于硬件故障、驱动问题或配置错误造成的，这些需要检查系统日志或硬件状态

内



分页和交换有什么区别？


解释什么是 OOM killer”


## 高级网络

##当你运行 ip a 时，你会看到有一个叫做 'lo' 的设备。它是什么，我们为什么需要它？

- 'lo' 是一个**回环设备**，它是一个虚拟的网络接口，用于在本地主机上进行通信

- 我们需要它，因为它可以用于测试网络连接、配置服务、调试应用程序等


## traceroute 命令的作用是什么？它是如何工作的？

- traceroute 命令的作用是**追踪**一个数据包从源主机到目的主机的**路由路径**，并显示每个中间节点的**延迟**和**丢包**情况

- 它是通过发送一系列的**ICMP**（Internet Control Message Protocol）**回显请求**数据包，每个数据包的**TTL**（Time To Live）值逐渐增加，从而触发每个中间节点返回一个**ICMP**回显应答或一个**ICMP**超时错误的消息，从而得到路径上的节点信息


## 网络绑定是什么？你熟悉哪些类型？

- 网络绑定是一种**将多个物理网络接口组合成一个逻辑网络接口**的技术，用于提高网络的**吞吐量**和**冗余性**

- 我熟悉的类型有**负载均衡**（load balancing）、**主备**（active-backup）、**广播**（broadcast）、**聚合**（aggregation）等


## 如何连接两个独立的网络命名空间，以便你可以从一个命名空间中 ping 另一个命名空间的接口？

- 一种方法是使用**veth**（虚拟以太网）**对**，它是一种成对的虚拟网络设备，可以在两个命名空间之间建立一个**点对点**的连接

- 例如，如果有两个命名空间 ns1 和 ns2，可以使用以下命令创建一个 veth 对 veth1 和 veth2，并将它们分别分配给 ns1 和 ns2：


ip link add veth1 type veth peer name veth2

ip link set veth1 netns ns1

ip link set veth2 netns ns2


- 然后，可以在每个命名空间中为 veth 设备分配 IP 地址，并启用它们：


ip netns exec ns1 ip addr add 10.0.0.1/24 dev veth1

ip netns exec ns1 ip link set veth1 up

ip netns exec ns2 ip addr add 10.0.0.2/24 dev veth2

ip netns exec ns2 ip link set veth2 up


- 最后，就可以从一个命名空间中 ping 另一个命名空间的接口了：


ip netns exec ns1 ping 10.0.0.2

ip netns exec ns2 ping 10.0.0.1


## cgroups 是什么？

- cgroups 是一种**控制组**的机制，它可以用于**限制**、**记录**和**隔离**进程或线程组使用的**系统资源**，如 CPU、内存、磁盘、网络等

- cgroups 由一组**层次结构**的**控制器**和一组**子系统**组成，每个控制器负责管理一种或多种资源，每个子系统负责实现一种或多种控制器的功能

- cgroups 可以用于实现各种功能，如**资源限制**（resource limiting）、**优先级分配**（priority allocation）、**计费**（accounting）、**监控**（monitoring）、**沙箱**（sandboxing）等


## 解释进程描述符和任务结构

- 进程描述符是一个**结构体**，它包含了一个进程或线程的所有**信息**和**状态**，如 PID、PPID、优先级、信号、寄存器、栈、内存映射、打开的文件、子进程等

- 任务结构是一个**链表**，它包含了系统中所有**活动**的进程描述符的指针，每个进程描述符都有一个**任务结构节点**，用于在链表中定位和遍历


## 进程和线程有什么区别？

- 进程是一个执行中的程序的实例，它有自己的地址空间、资源和状态

- 线程是进程内的一个执行单元，它共享进程的地址空间、资源和状态，但有自己的栈、寄存器和程序计数器


解释内核线程

- 内核线程是一种**运行在内核空间**的线程，它不属于任何用户进程，而是由**内核**创建和管理的

- 内核线程可以用于执行各种**内核任务**，如中断处理、系统调用、定时器、设备驱动、内存管理等

- 内核线程可以分为两种类型：**可抢占**的和**不可抢占**的，前者可以被其他线程打断，后者则不能


## 当使用 socket 系统调用时会发生什么？

- socket 系统调用是用于**创建**一个**套接字**的函数，套接字是一种**通信端点**，可以用于在**本地**或**远程**的进程或主机之间进行**数据交换**

- socket 系统调用会返回一个**套接字描述符**，它是一个整数，用于标识和操作套接字

- socket 系统调用需要指定三个参数：**域**（domain）、**类型**（type）和**协议**（protocol），它们分别决定了套接字的**地址格式**、**通信方式**和**通信规则**


## 你执行了一个脚本，而它在运行时被意外删除了。在它还在运行的时候，有可能恢复这个脚本吗？

- 有可能，因为在 Linux 系统中，当一个文件被打开时，它的**索引节点**（inode）会被**锁定**，即使文件被删除，它的索引节点和数据块仍然存在，直到所有打开它的进程都关闭它

- 因此，如果我们知道这个脚本的**进程 ID**（PID），我们可以通过查看 /proc/PID/fd 目录下的**符号链接**，找到它的索引节点号，然后使用 debugfs 工具来**复制**它的内容到一个新的文件中


